**<u>Scenario 3</u>**: Credential Access Attempt (Recon / Lateral Movement Preparation)

**<u>Attack Behavior</u>**:

After an initial compromise, the attacker will likely begin to enumerate  user context, account information and network configuration.  They may download custom tools, in which further examination of indicators discovered in Scenario 2 would be critical.  Or they may reduce their profile by using tools readily available on the victim machine (living off the land). Here we'll focus on the later.

Commands like:
<ul>
	<li> whoami </li>
	<li> net user </li>
	<li> net user /domain </li>
	<li> ipconfig /all </li>
</ul>

help determine current privilege level, available user account and membership as well as the network layout. An average Windows user would be less likely to access this information through the command line; they'd be more likely to use the GUI or work directly with their Administrator. Use of these commands indicate interactive access and preparation for lateral movement.

**<u>Telemetry Generated</u>**:
	
Sysmon:
	<ul> EventID 1 - Process creation
		<li> whoami.exe </li>
		<li> net.exe </li>
		<li> ipconfig.exe </li>
		<li> cmd.exe </li>
	Key fields:
		<li> Image </li>
		<li> CommandLine </li>
		<li> ParentImage </li>
		<li> User </li>
		<li> ProcessId </li>
	</ul>
Suricata:
	<ul>
		<li> ET POLICY alerts </li>
		<li> Unusual outbound connections </li>
	</ul>
		
**<u>Attack Simulation</u>**:

Lab Goal: Detect attempt at lateral movement and trace back to signs of initial compromise.

Initial Attack:

Enumeration of user:

<img src="images/Scenario3Enumeration1.png"
	alt="Enumeration 1"
	style="display: block; margin: 0 auto"
	width="90%"	/>

Enumeration of network:

<img src="images/Scenario3Enumeration2.png"
	alt="Enumeration 2"
	style="display: block; margin: 0 auto"
	width="90%"	/>

<img src="images/Scenario3Enumeration3.png"
	alt="Enumeration 3"
	style="display: block; margin: 0 auto"
	width="90%"	/>

Enumeration of File System:

<img src="images/Scenario3Enumeration4.png"
	alt="Enumeration 4"
	style="display: block; margin: 0 auto"
	width="90%"	/>
	
<img src="images/Scenario3Enumeration5.png"
	alt="Enumeration 5"
	style="display: block; margin: 0 auto"
	width="90%"	/>
	
Attempted Lateral Movement:

<img src="images/Scenario3Enumeration6.png"
	alt="Enumeration 6"
	style="display: block; margin: 0 auto"
	width="90%"	/>

In order to detect this failed attempt at establishing a secure shell, we need to ensure we're ingesting the correct logs.  We can verify our Splunk sources with:

```
index=main
| stats count by sourcetype
| sort -count
```	
		

<img src="images/Scenario3SourceTypes.png"
	alt="Splunk Source Types"
	style="display: block; margin: 0 auto"
	width="90%"	/>

We will need the following additional sources from our Ubuntu server via Universal Forwarder:

<ul>
	<li> auth.log  as linux_secure
	<li> audit.log as auditd
</ul>

To the ```/opt/splunkforwarder/etc/system/local/inputs.conf``` file we need to add:

```
[monitor://var/log/auth.log]
index = main
sourcetype = linux_secure
disabled = false

[monitor:///var/log/audit/audit.log]
index = main
sourcetype = auditd
disabled = false
```

Now we restart the forwarder:

```
$ sudo /opt/splunkforwarder/bin/splunk restart
```

Now when we check our Splunk sources we see:

<img src="images/Scenario3AdditionalSourceTypes.png"
	alt="Additional Splunk Source Types"
	style="display: block; margin: 0 auto"
	width="90%"	/>

Now we can check for failed ssh attempts:

```
index=main sourcetype=linux_secure "Failed password"
```

<img src="images/Scenario3FailedPassword.png"
	alt="Additional Splunk Source Types"
	style="display: block; margin: 0 auto"
	width="90%"	/>
	
Upon discovery of three failed password attempts in short succession, we can dig deeper to find the origin.

Looking at the Raw view, we can see the actual log entries which show the time, host, search term, user source IP and source port.

<img src="images/Scenario3RawLog.png"
	alt="Raw auth log entries"
	style="display: block; margin: 0 auto"
	width="90%"	/>
	
Now that we know the source IP, we can pivot back and see that it's our windows box.  Using regular expressions to create fields for the user and src_ip based on the expected format of the auth.log and extract them:

```
index=main sourcetype=linux_secure "Failed password"
| rex "Failed password for (invalid user )?(?<user>\S+) from (?<src_ip>\d{1,3}(?:\.\d{1,3}){3})"
| table _time host user src_ip
| sort _time
```

<img src="images/Scenario3ExtractWithRegex.png"
	alt="Extracted fields with regex"
	style="display: block; margin: 0 auto"
	width="90%"	/>

We can now pivot back to the originating box by looking at the surrounding window of time:

```
index=main (source="XmlWinEventLog:Microsoft-Windows-Sysmon/Operational" OR source="XmlWinEventLog:Security")
earliest="01/12/2026:22:20:00"
latest="01/12/2026:22:30:00"
User!="NT AUTHORITY\\SYSTEM"
(EventID=1 OR EventCode=4663)
NOT "splunk*"
| spath
| table _time EventID host User CommandLine TargetFilename
| sort _time desc
```


<img src="images/Scenario3AttackChain.png"
	alt="Attack Chain"
	style="display: block; margin: 0 auto"
	width="90%"	/>
	
I included the security log in my sources and searched for EventCode 4663 to catch the file access we conducted using the type command, but it didn't appear in my results.

Furthermore:

```
index=main source="XmlWinEventLog:Security"
earliest="01/12/2026:22:20:00"
latest="01/12/2026:22:30:00"
EventCode=4663
```

returned no results. Windows doesn't log file access by default; it would be very noisy. An anti-virus scan, for example, would generate a lot of file access logs.  We could enable access logging for specific, high value files, but it is difficult to do at scale.

But why didn't type show up as a command line executable?  Type is built in to the cmd binary, so no new process is spawned when it's run. The commands arp and ssh are actual binaries, so they create new processes which trigger EventID 1.

This is notable from both a red and blue team perspective; in Scenario 2, we enabled PowerShell logging which records Script Block Text, so if we use Get-Content, we can find the command, thus the file access, in our logs.

<img src="images/Scenario3Get-Content.png"
	alt="Get-Content"
	style="display: block; margin: 0 auto"
	width="90%"	/>

Because we had assumed compromise for this lab, we won't see any other indicators of what events occured before the whoami command. If we had run a full attack chain which included initial access, we might be able to pivot from  our initial series of enumeration commands and further trace the attack.

Attacks stages may not be timed closely together. For example, if our malicious actor obtains the credentials and uses them at a later date or from a different computer, it may be more difficult to correlate.

Let's take a look at a brute force attack. We have our search for Failed Password. Let's turn it into an alert with a noticeable action.

From our attacking box (kali), we'll run:

```
$ hydra -l SOC-LAB -P /usr/share/wordlists/rockyou.txt.gz 192.168.228.130 ssh
```

<img src="images/Scenario3HydraAttack.png"
	alt="Hydra Brute Force"
	style="display: block; margin: 0 auto"
	width="90%"	/>

Using our previous search 
```
index=main sourcetype=linux_secure 
"Failed password" 
| sort _time desc
```

We can see that we have many tightly spaced Failed password hits.

<img src="images/Scenario3Hydra.png"
	alt="Hydra Brute Force in SPlunk"
	style="display: block; margin: 0 auto"
	width="90%"	/>
	
Lets turn this into an alert by using the Save As button in the upper right hand corner of the Splunk search page.

<img src="images/Scenario3BruteForceAlert.png"
	alt="Brute Force Alert"
	style="display: block; margin: 0 auto"
	/>
	
Here we set the alert to run every minute and check the last 5 minutes for more than 10 failed password attempts.  This will trigger the alert once, and after it's triggered, we'll suppress the trigger for 10 minutes.

<img src="images/Scenario3BruteForceAlertAction.png"
	alt="Brute Force Actions"
	style="display: block; margin: 0 auto"
	/>

For actions, we'll add it to our triggered alerts and also run a script.

On our SIEM server, create a script and make it executable by splunk:

```
$ cat /opt/splunk/bin/scripts/run_on_brute.sh
#!/bin/bash

wall "Brute Force Detected"
$ sudo chmod +x run_on_brute.sh
$ sudo chown splunk:splunk run_on_brute.sh
```

However, although the throttle was set, the script was still being run on every hit. 

We can clean this up by setting a threshold in the alert itself.

```
index=main sourcetype=linux_secure "Failed password"
| rex "Failed password for (invalid user )?(?<user>\S+) from (?<src_ip>\d{1,3}(?:\.\d{1,3}){3})"
| bin _time span=1m
| stats count by _time src_ip
| where count > 5
```

This will trigger when more than 5 Failed password attempts are made within one minute of each other.

Now our script runs more meaningfully:

<img src="images/Scenario3BruteForceTriggered.png"
	alt="Brute Force Actions"
	style="display: block; margin: 0 auto"
	/>

**<u>MITRE ATT&CK Mapping</u>**:


| Tactic              | Technique | Evidence |
| ------------------- | --------- | -------- |
| Initial Access      | T1078     | Repeated authentication attempts |
|                     |           | &ensp;against SSH service |
| Credential Access   | T1110     | Multiple failed password attempts |
|                     |           | &ensp;from same source IP |
| Persistence         | T1078     | Attempted use of valid account |
|                     |           | &ensp;credentials via SSH |
| Lateral Movement    | T1021.004 | SSH authentication attempts |
|                     |           | &ensp;to remote Linux host |
| Reconnaissance      | T1595     | Brute-force probing of |
|                     |           | &ensp;SSH login interface |
